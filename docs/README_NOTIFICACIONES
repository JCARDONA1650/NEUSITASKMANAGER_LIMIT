Sistema de Notificaciones (Campana)

NeusiTaskManager â€“ Plan Free

1. Objetivo del sistema

El sistema de notificaciones tiene como objetivo:
Informar eventos clave del flujo de trabajo sin depender de correos.
Mantener alineados a responsables y roles administrativos.
Reflejar el estado real del trabajo (asignaciÃ³n, entrega, correcciÃ³n).
Funcionar de forma centralizada, auditable y en tiempo real dentro de la app.

Las notificaciones aparecen en una campana ğŸ”” en el navbar, con contador de no leÃ­das, y un listado histÃ³rico accesible por el usuario.

2. Arquitectura tÃ©cnica
2.1 Modelo de datos
class Notification(models.Model):
    recipient   # Usuario que recibe la notificaciÃ³n
    actor       # Usuario que dispara el evento (opcional)
    verb        # Tipo de evento (string corto)
    title       # TÃ­tulo visible
    message     # Mensaje detallado
    url         # Ruta interna al detalle (task_detail)
    is_read     # Estado leÃ­do / no leÃ­do
    created_at  # Fecha de creaciÃ³n


CaracterÃ­sticas:

Persistente en base de datos.
Ordenada por created_at DESC.
Compatible con mÃºltiples receptores por evento.
No depende de seÃ±ales automÃ¡ticas (control explÃ­cito desde views).
2.2 Helpers de notificaciÃ³n (core/notifications.py)

Funciones principales:

notify_many(...)
notify_task_assigned_new(...)
notify_task_completed_to_admins(...)
notify_task_returned_with_comment(...)

Estas funciones NO importan views, evitando imports circulares.
Las views importan los helpers de forma local.

2.3 Context Processor

Archivo: core/context_processors.py

def notifications_context(request):
    if not request.user.is_authenticated:
        return {}

    unread = Notification.objects.filter(
        recipient=request.user,
        is_read=False
    ).count()

    return {
        "notif_unread": unread
    }


Esto permite:

Mostrar el contador en todas las vistas
Sin duplicar lÃ³gica en cada view

Configurado en:

TEMPLATES -> OPTIONS -> context_processors
2.4 UI â€“ Navbar (Campana)
Visible solo si el usuario estÃ¡ autenticado.
Muestra badge si hay notificaciones no leÃ­das.

Redirige a /notifications/.

Ejemplo:

<a href="{% url 'notifications_list' %}">
  ğŸ””
  <span class="neu-bell-badge">{{ notif_unread }}</span>
</a>

3. Reglas funcionales de notificaciÃ³n (CORE)
ğŸ”¹ Regla 1 â€“ AsignaciÃ³n de tarea nueva

CondiciÃ³n

Un usuario con rol tipo admin crea una tarea
Asigna responsables
La tarea queda en estado NEW

Resultado

ğŸ”” Se notifica a todos los responsables
âŒ No se notifica al actor (si tambiÃ©n es responsable)

FunciÃ³n

notify_task_assigned_new(task, actor)
ğŸ”¹ Regla 2 â€“ Tarea completada

CondiciÃ³n

Cualquier usuario (admin o no)
Cambia el estado a COMPLETED
Desde Kanban o desde Task Detail

Resultado

ğŸ”” Se notifica a todos los roles tipo admin
âŒ No se notifica al actor
âŒ No se notifica a responsables

FunciÃ³n

notify_task_completed_to_admins(task, actor)

ğŸ”¹ Regla 3 â€“ CorrecciÃ³n / devoluciÃ³n de tarea

CondiciÃ³n

Usuario admin

Cambia estado de COMPLETED â†’ IN_PROGRESS
Agrega comentario obligatorio (solo en Kanban)

Resultado

ğŸ”” Se notifica a todos los responsables

Incluye comentario de correcciÃ³n

âŒ No se notifica al actor

FunciÃ³n

notify_task_returned_with_comment(task, actor, comment)

4. Diferencia entre Kanban y Task Detail
ğŸ”¸ Kanban (task_move)

Permite:

Avanzar y retroceder estados
Agregar comentario obligatorio al retroceder

Dispara:

Regla 2
Regla 3

ğŸ”¸ Task Detail (task_update_status)

Cambio simple de estado vÃ­a select
No tiene campo comentario

Dispara:

âœ… Regla 2 (COMPLETED)
âŒ Regla 3 (no aplica aquÃ­)

Esto es intencional, para forzar correcciones documentadas desde Kanban.

5. Comportamiento con mÃºltiples responsables

Si una tarea tiene varios responsables:

Regla 1 â†’ todos reciben notificaciÃ³n
Regla 3 â†’ todos reciben notificaciÃ³n

El actor siempre se excluye, incluso si es responsable.

6. Vista de Notificaciones

Ruta:

/notifications/


Funciones:

Ver historial
Ver no leÃ­das
Marcar individual como leÃ­da
Marcar todas como leÃ­das
No hay borrado fÃ­sico (auditorÃ­a implÃ­cita).

7. Consideraciones del Plan Free

No hay push en tiempo real (WebSockets).
No hay emails.
Todo es in-app.
Persistente pero sin reglas complejas por usuario.

Escalable a:

WebSockets
Emails
Preferencias por usuario
Notificaciones por subtareas

8. Decisiones de diseÃ±o (importantes)

âŒ No se usan signals automÃ¡ticos
âœ… Las notificaciones se disparan solo donde el negocio lo exige
âœ… Imports locales para evitar ciclos
âœ… Reglas explÃ­citas y auditables
âœ… UX clara: campana = â€œalgo requiere tu atenciÃ³nâ€

9. Glosario rÃ¡pido

Actor: Usuario que provoca el evento
Recipient: Usuario que recibe la notificaciÃ³n
Verb: Tipo tÃ©cnico del evento
Admin-like: admin, leader, scrum, superuser
Responsable: Usuario asignado a una tarea